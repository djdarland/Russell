Function closures may be represented in one of four possible ways:

1) Not at all. This normally happens in the case of a procedure
  which is used only in the calling position of procedure calls.
  The environment pointer (if needed) and the code pointer are
  generated by the code at the call site.

2) As a heap allocated triple:

		Activation record size (negative ==> may need to be on heap)
		Pointer to activation record of surr. procedure (environment)
		Code pointer

3) As an n-tuple, with the first 3 fields layed out as above, but
   with the environment pointer replaced by a pointer to the closure
   itself.  The rest of the closure consists of the non-local identifier
   bindings themselves:

	  ---->
	  |     Activation record size
	  ----------
		Code pointer
		Non-local 1
		Non-local 2
		...

   This is used for innermost procedures that appear as though they
   might outlive an invovation of the surrounding procedure.  Note
   that when such a procedure is invoked its global environment
   pointer will point to the closure rather than the activation
   record of the procedure in which it was declared.  Identifier
   references inside the procedure are compiled accordingly.  (Note
   that references to objects declared at the outermost level are
   benign, and do not force copying into the closure, since they
   are always accessible.  Also note that stack allocated variables
   do not cause problems.  We simply copy a pointer to the stack into
   the closure.  The analysis guaranteeing that the variable could
   not outlive the invocation of the declaring procedure still applies.)

   This style of closure tends to be used primarily for functions that look
   "Curried".  Note that it interacts badly with calls to type (1)
   functions, since we can't get to a real environment pointer
   while executing a function compiled with this style of closure.
   Furthermore calls to such functions are relatively expensive,
   since we ALWAYS need to explicitly produce the environment pointer.

4) In the event of a single non-local variable reference, the above
   is simplified to:

		Activation record size
		Non-local 1
		Code pointer

   In this case the procedure will see the non-local binding as its
   global environment.

Crucial observations:

1) The caller does not need to know which of 2,3, or 4 applies.
  The calling sequence differs only in case 1.  Case 1 is used only
  when we know about all possible callers.

2) Pascal-style global environments are always available for use in
  case 2, since we use cases 3 and 4 only for innermost procedures.

3) Activation record sizes are needed in closures so that the activation
  record can be built by the caller, and arguments can be put directly
  into their final position in the activation record (whether it's on
  the stack or the heap).  (A possible improvement would be to pass
  parameters in registers and have the callee build the activation record.
  There are also a few counterarguments in favor of the present solution,
  e.g. the caller has more info that might be helpful in deciding
  to place activation record on stack.)

Arguments against uniform use of case 2:

1) Forces more retention.

2) Forces activation records to be heap allocated.
   Type 3 and 4 closures do not preserve references to activation records.
   (Closures must still be heap allocated.)

Arguments against uniform use of 3 and 4:

1) Since globals are always obtained from closures, closures must be
   built even in the simplest cases.  Case 1 becomes impossible.

2) General recursion is a mess.  It's hard to copy a binding that hasn't
   yet been created.  The extra level of indirection through the activation
   record makes this much easier.  Most languages normally implemented
   with this type of closure restrict right-hand-sides of letrec's to be
   lambda-abstractions.  In this case, the closure objects themselves
   provide the indirection.  I don't know of a good way of dealing with
   forward references to objects not known to be closures.  (Turning
   them into functions with no arguments is a bad way of doing this.)
